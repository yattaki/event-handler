{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["/** Specifies characteristics about the listener. */\nexport interface EventHandlerOptions<T extends { [key: string]: any } = { [key: string]: any }> {\n  /**\n   * A Boolean indicating that the listener should be invoked at most once after being added.\n   * If true, the listener would be automatically removed when invoked.\n   */\n  once?: boolean\n\n  /**\n   * A Boolean indicating that it should wait for listener processing.\n   * If true, the next listener will not be executed until the listener processing is completed.\n   */\n  wait?: boolean\n\n  /**\n   * An object to be passed as an argument of the listener.\n   */\n  data?: T\n}\n\n/** Argument object that the listener receives. */\nexport interface EventHandlerListenerEvent<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> {\n  /** This represents the name of the event. */\n  type: U\n\n  /** This represents the class that received the event. */\n  target: V\n\n  /**\n   * This is the initial value for options passed to the event.\n   * When passed, it may be overwritten.\n   */\n  data: T\n}\n\n/** This represents a listener. */\nexport type EventHandlerListener<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> =\n  (ev: EventHandlerListenerEvent<T, U, V>) => void | Promise<void>\n\n/** This represents the data map when it was dispatched. */\nexport interface EventHandlerDataMap {\n  [key: string]: { [key: string]: any }\n}\n\nclass EventHandler<M extends EventHandlerDataMap = EventHandlerDataMap> {\n  private readonly _map: Map<string, { listener: EventHandlerListener<any, any, any>, options: EventHandlerOptions }[]> = new Map()\n\n  /**\n   * Add a new listener.\n   * @param type This represents the name of the event.\n   * @param listener This represents the listener to add.\n   * @param options Specifies characteristics about the event listener.\n   */\n  addEventListener<T extends Extract<keyof M, string>, U extends Partial<M[T]> = M[T], V extends this = this> (\n    type: T,\n    listener: EventHandlerListener<M[T] & U, T, V>,\n    options: EventHandlerOptions<U> = {}\n  ) {\n    let onMaps = this._map.get(type)\n    if (!onMaps) {\n      onMaps = []\n      this._map.set(type, onMaps)\n    }\n\n    let isAdd = true\n\n    for (const onMap of onMaps) {\n      if (onMap.listener === listener) {\n        onMap.options = options\n        isAdd = false\n        break\n      }\n    }\n\n    if (isAdd) { onMaps.push({ listener, options }) }\n\n    return isAdd\n  }\n\n  /**\n   * Remove the listener.\n   * @param type This represents the name of the event.\n   * @param listener This represents the listener to remove.\n   */\n  removeEventListener (type: Extract<keyof M, string>, listener: EventHandlerListener) {\n    const onMaps = this._map.get(type)\n    if (onMaps) {\n      let index = 0\n      for (const onMap of onMaps) {\n        if (onMap.listener === listener) {\n          onMaps.splice(index, 1)\n          return true\n        }\n\n        index++\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Execute the registered event.\n   * @param type This represents the name of the event.\n   * @param data An object to be passed as an argument of the listener.\n   */\n  async dispatchEvent<T extends Extract<keyof M, string>> (type: T, data: M[T] = {} as M[T]) {\n    const promises: (Promise<void> | void)[] = []\n\n    const onMaps = this._map.get(type)\n    if (onMaps) {\n      for (const { listener, options } of [...onMaps]) {\n        const event = {\n          type,\n          target: this,\n          data: { ...(options.data || {}), ...data }\n        }\n\n        const promise = listener(event)\n        promises.push(promise)\n\n        if (options.once) { this.removeEventListener(type, listener) }\n        if (options.wait) { await promise }\n      }\n    }\n\n    await Promise.all(promises)\n  }\n}\n\nexport default EventHandler\n"],"names":["[object Object]","this","Map","type","listener","options","onMaps","_map","get","set","isAdd","onMap","push","index","splice","data","promises","promise","target","once","removeEventListener","wait","Promise","all"],"mappings":"0MA4CA,MAAAA,cACmBC,UAAuG,IAAIC,IAQ5HF,iBACEG,EACAC,EACAC,EAAkC,IAElC,IAAIC,EAASL,KAAKM,KAAKC,IAAIL,GACtBG,IACHA,EAAS,GACTL,KAAKM,KAAKE,IAAIN,EAAMG,IAGtB,IAAII,GAAQ,EAEZ,IAAK,MAAMC,KAASL,EAClB,GAAIK,EAAMP,WAAaA,EAAU,CAC/BO,EAAMN,QAAUA,EAChBK,GAAQ,EACR,MAMJ,OAFIA,GAASJ,EAAOM,KAAK,CAAER,SAAAA,EAAUC,QAAAA,IAE9BK,EAQTV,oBAAqBG,EAAgCC,GACnD,MAAME,EAASL,KAAKM,KAAKC,IAAIL,GAC7B,GAAIG,EAAQ,CACV,IAAIO,EAAQ,EACZ,IAAK,MAAMF,KAASL,EAAQ,CAC1B,GAAIK,EAAMP,WAAaA,EAErB,OADAE,EAAOQ,OAAOD,EAAO,IACd,EAGTA,KAIJ,OAAO,EAQTb,oBAAyDG,EAASY,EAAa,IAC7E,MAAMC,EAAqC,GAErCV,EAASL,KAAKM,KAAKC,IAAIL,GAC7B,GAAIG,EACF,IAAK,MAAMF,SAAEA,EAAQC,QAAEA,IAAa,IAAIC,GAAS,CAC/C,MAMMW,EAAUb,EANF,CACZD,KAAAA,EACAe,OAAQjB,KACRc,KAAM,IAAMV,EAAQU,MAAQ,MAAQA,KAItCC,EAASJ,KAAKK,GAEVZ,EAAQc,MAAQlB,KAAKmB,oBAAoBjB,EAAMC,GAC/CC,EAAQgB,YAAcJ,QAIxBK,QAAQC,IAAIP"}