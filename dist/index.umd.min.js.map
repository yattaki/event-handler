{"version":3,"file":"index.umd.min.js","sources":["../src/index.ts"],"sourcesContent":["/** Specifies characteristics about the listener. */\r\ninterface EventHandlerOptions<T extends { [key: string]: any } = { [key: string]: any }> {\r\n  /**\r\n   * A Boolean indicating that the listener should be invoked at most once after being added.\r\n   * If true, the listener would be automatically removed when invoked.\r\n   */\r\n  once?: boolean\r\n\r\n  /**\r\n   * A Boolean indicating that it should wait for listener processing.\r\n   * If true, the next listener will not be executed until the listener processing is completed.\r\n   */\r\n  wait?: boolean\r\n\r\n  /**\r\n   * An object to be passed as an argument of the listener.\r\n   */\r\n  data?: T\r\n}\r\n\r\n/** Argument object that the listener receives. */\r\nexport type EventHandlerListenerEvent<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> = {\r\n  /** This represents the name of the event. */\r\n  type: U\r\n\r\n  /** This represents the class that received the event. */\r\n  target: V\r\n\r\n  /**\r\n   * This is the initial value for options passed to the event.\r\n   * When passed, it may be overwritten.\r\n   */\r\n  data: T\r\n}\r\n\r\n/** This represents a listener. */\r\nexport type EventHandlerListener<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> =\r\n  (ev: EventHandlerListenerEvent<T, U, V>) => void | Promise<void>\r\n\r\n/** This represents the data map when it was dispatched. */\r\nexport type EventHandlerDataMap = {\r\n  [key: string]: { [key: string]: any }\r\n}\r\n\r\nclass EventHandler<M extends EventHandlerDataMap = EventHandlerDataMap> {\r\n  private readonly _map: Map<string, { listener: EventHandlerListener<any, any, any>, options: EventHandlerOptions }[]> = new Map()\r\n\r\n  /**\r\n   * Add a new listener.\r\n   * @param type This represents the name of the event.\r\n   * @param listener This represents the listener to add.\r\n   * @param options Specifies characteristics about the event listener.\r\n   */\r\n  addEventListener<T extends Extract<keyof M, string>, U extends Partial<M[T]> = M[T], V extends this = this> (\r\n    type: T,\r\n    listener: EventHandlerListener<M[T] & U, T, V>,\r\n    options: EventHandlerOptions<U> = {}\r\n  ) {\r\n    let onMaps = this._map.get(type)\r\n    if (!onMaps) {\r\n      onMaps = []\r\n      this._map.set(type, onMaps)\r\n    }\r\n\r\n    let isAdd = true\r\n\r\n    for (const onMap of onMaps) {\r\n      if (onMap.listener === listener) {\r\n        onMap.options = options\r\n        isAdd = false\r\n        break\r\n      }\r\n    }\r\n\r\n    if (isAdd) { onMaps.push({ listener, options }) }\r\n\r\n    return isAdd\r\n  }\r\n\r\n  /**\r\n   * Remove the listener.\r\n   * @param type This represents the name of the event.\r\n   * @param listener This represents the listener to remove.\r\n   */\r\n  removeEventListener (type: Extract<keyof M, string>, listener: EventHandlerListener) {\r\n    const onMaps = this._map.get(type)\r\n    if (onMaps) {\r\n      let index = 0\r\n      for (const onMap of onMaps) {\r\n        if (onMap.listener === listener) {\r\n          onMaps.splice(index, 1)\r\n          return true\r\n        }\r\n\r\n        index++\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Execute the registered event.\r\n   * @param type This represents the name of the event.\r\n   * @param data An object to be passed as an argument of the listener.\r\n   */\r\n  async dispatchEvent<T extends Extract<keyof M, string>> (type: T, data: M[T] = {} as M[T]) {\r\n    const promises: (Promise<void> | void)[] = []\r\n\r\n    const onMaps = this._map.get(type)\r\n    if (onMaps) {\r\n      for (const { listener, options } of [...onMaps]) {\r\n        const event = {\r\n          type,\r\n          target: this,\r\n          data: { ...(options.data || {}), ...data }\r\n        }\r\n\r\n        const promise = listener(event)\r\n        promises.push(promise)\r\n\r\n        if (options.once) { this.removeEventListener(type, listener) }\r\n        if (options.wait) { await promise }\r\n      }\r\n    }\r\n\r\n    await Promise.all(promises)\r\n  }\r\n}\r\n\r\nexport default EventHandler\r\n"],"names":["[object Object]","this","Map","type","listener","options","onMaps","_map","get","set","isAdd","onMap","push","index","splice","data","promises","promise","target","once","removeEventListener","wait","Promise","all"],"mappings":"0MA4CA,MAAAA,cACmBC,UAAuG,IAAIC,IAQ5HF,iBACEG,EACAC,EACAC,EAAkC,IAElC,IAAIC,EAASL,KAAKM,KAAKC,IAAIL,GACtBG,IACHA,EAAS,GACTL,KAAKM,KAAKE,IAAIN,EAAMG,IAGtB,IAAII,GAAQ,EAEZ,IAAK,MAAMC,KAASL,EAClB,GAAIK,EAAMP,WAAaA,EAAU,CAC/BO,EAAMN,QAAUA,EAChBK,GAAQ,EACR,MAMJ,OAFIA,GAASJ,EAAOM,KAAK,CAAER,SAAAA,EAAUC,QAAAA,IAE9BK,EAQTV,oBAAqBG,EAAgCC,GACnD,MAAME,EAASL,KAAKM,KAAKC,IAAIL,GAC7B,GAAIG,EAAQ,CACV,IAAIO,EAAQ,EACZ,IAAK,MAAMF,KAASL,EAAQ,CAC1B,GAAIK,EAAMP,WAAaA,EAErB,OADAE,EAAOQ,OAAOD,EAAO,IACd,EAGTA,KAIJ,OAAO,EAQTb,oBAAyDG,EAASY,EAAa,IAC7E,MAAMC,EAAqC,GAErCV,EAASL,KAAKM,KAAKC,IAAIL,GAC7B,GAAIG,EACF,IAAK,MAAMF,SAAEA,EAAQC,QAAEA,IAAa,IAAIC,GAAS,CAC/C,MAMMW,EAAUb,EANF,CACZD,KAAAA,EACAe,OAAQjB,KACRc,KAAM,IAAMV,EAAQU,MAAQ,MAAQA,KAItCC,EAASJ,KAAKK,GAEVZ,EAAQc,MAAQlB,KAAKmB,oBAAoBjB,EAAMC,GAC/CC,EAAQgB,YAAcJ,QAIxBK,QAAQC,IAAIP"}