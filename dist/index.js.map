{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["/** Specifies characteristics about the listener. */\nexport interface EventHandlerOptions<T extends { [key: string]: any } = { [key: string]: any }> {\n  /**\n   * A Boolean indicating that the listener should be invoked at most once after being added.\n   * If true, the listener would be automatically removed when invoked.\n   */\n  once?: boolean\n\n  /**\n   * A Boolean indicating that it should wait for listener processing.\n   * If true, the next listener will not be executed until the listener processing is completed.\n   */\n  wait?: boolean\n\n  /**\n   * An object to be passed as an argument of the listener.\n   */\n  data?: T\n}\n\n/** Argument object that the listener receives. */\nexport interface EventHandlerListenerEvent<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> {\n  /** This represents the name of the event. */\n  type: U\n\n  /** This represents the class that received the event. */\n  target: V\n\n  /**\n   * This is the initial value for options passed to the event.\n   * When passed, it may be overwritten.\n   */\n  data: T\n}\n\n/** This represents a listener. */\nexport type EventHandlerListener<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> =\n  (ev: EventHandlerListenerEvent<T, U, V>) => void | Promise<void>\n\n/** This represents the data map when it was dispatched. */\nexport interface EventHandlerDataMap {\n  [key: string]: { [key: string]: any }\n}\n\nclass EventHandler<M extends EventHandlerDataMap = EventHandlerDataMap> {\n  private readonly _map: Map<string, { listener: EventHandlerListener<any, any, any>, options: EventHandlerOptions }[]> = new Map()\n\n  /**\n   * Add a new listener.\n   * @param type This represents the name of the event.\n   * @param listener This represents the listener to add.\n   * @param options Specifies characteristics about the event listener.\n   */\n  addEventListener<T extends Extract<keyof M, string>, U extends Partial<M[T]> = M[T], V extends this = this> (\n    type: T,\n    listener: EventHandlerListener<M[T] & U, T, V>,\n    options: EventHandlerOptions<U> = {}\n  ) {\n    let onMaps = this._map.get(type)\n    if (!onMaps) {\n      onMaps = []\n      this._map.set(type, onMaps)\n    }\n\n    let isAdd = true\n\n    for (const onMap of onMaps) {\n      if (onMap.listener === listener) {\n        onMap.options = options\n        isAdd = false\n        break\n      }\n    }\n\n    if (isAdd) { onMaps.push({ listener, options }) }\n\n    return isAdd\n  }\n\n  /**\n   * Remove the listener.\n   * @param type This represents the name of the event.\n   * @param listener This represents the listener to remove.\n   */\n  removeEventListener (type: Extract<keyof M, string>, listener: EventHandlerListener) {\n    const onMaps = this._map.get(type)\n    if (onMaps) {\n      let index = 0\n      for (const onMap of onMaps) {\n        if (onMap.listener === listener) {\n          onMaps.splice(index, 1)\n          return true\n        }\n\n        index++\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Execute the registered event.\n   * @param type This represents the name of the event.\n   * @param data An object to be passed as an argument of the listener.\n   */\n  async dispatchEvent<T extends Extract<keyof M, string>> (type: T, data: M[T] = {} as M[T]) {\n    const promises: (Promise<void> | void)[] = []\n\n    const onMaps = this._map.get(type)\n    if (onMaps) {\n      for (const { listener, options } of [...onMaps]) {\n        const event = {\n          type,\n          target: this,\n          data: { ...(options.data || {}), ...data }\n        }\n\n        const promise = listener(event)\n        promises.push(promise)\n\n        if (options.once) { this.removeEventListener(type, listener) }\n        if (options.wait) { await promise }\n      }\n    }\n\n    await Promise.all(promises)\n  }\n}\n\nexport default EventHandler\n"],"names":[],"mappings":"AA4CA,MAAM,YAAY;IAAlB;QACmB,SAAI,GAAmG,IAAI,GAAG,EAAE,CAAA;KAmFlI;;;;;;;IA3EC,gBAAgB,CACd,IAAO,EACP,QAA8C,EAC9C,UAAkC,EAAE;QAEpC,IAAI,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAChC,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,GAAG,EAAE,CAAA;YACX,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;SAC5B;QAED,IAAI,KAAK,GAAG,IAAI,CAAA;QAEhB,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,IAAI,KAAK,CAAC,QAAQ,KAAK,QAAQ,EAAE;gBAC/B,KAAK,CAAC,OAAO,GAAG,OAAO,CAAA;gBACvB,KAAK,GAAG,KAAK,CAAA;gBACb,MAAK;aACN;SACF;QAED,IAAI,KAAK,EAAE;YAAE,MAAM,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAA;SAAE;QAEjD,OAAO,KAAK,CAAA;KACb;;;;;;IAOD,mBAAmB,CAAE,IAA8B,EAAE,QAA8B;QACjF,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAClC,IAAI,MAAM,EAAE;YACV,IAAI,KAAK,GAAG,CAAC,CAAA;YACb,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;gBAC1B,IAAI,KAAK,CAAC,QAAQ,KAAK,QAAQ,EAAE;oBAC/B,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAA;oBACvB,OAAO,IAAI,CAAA;iBACZ;gBAED,KAAK,EAAE,CAAA;aACR;SACF;QAED,OAAO,KAAK,CAAA;KACb;;;;;;IAOD,MAAM,aAAa,CAAsC,IAAO,EAAE,OAAa,EAAU;QACvF,MAAM,QAAQ,GAA6B,EAAE,CAAA;QAE7C,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAClC,IAAI,MAAM,EAAE;YACV,KAAK,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE;gBAC/C,MAAM,KAAK,GAAG;oBACZ,IAAI;oBACJ,MAAM,EAAE,IAAI;oBACZ,IAAI,EAAE,EAAE,IAAI,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE;iBAC3C,CAAA;gBAED,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAA;gBAC/B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;gBAEtB,IAAI,OAAO,CAAC,IAAI,EAAE;oBAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;iBAAE;gBAC9D,IAAI,OAAO,CAAC,IAAI,EAAE;oBAAE,MAAM,OAAO,CAAA;iBAAE;aACpC;SACF;QAED,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;KAC5B;;;;;"}