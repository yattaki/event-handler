{"version":3,"file":"index.cjs.js","sources":["../src/index.ts"],"sourcesContent":["/** Specifies characteristics about the listener. */\r\ninterface EventHandlerOptions<T extends { [key: string]: any } = { [key: string]: any }> {\r\n  /**\r\n   * A Boolean indicating that the listener should be invoked at most once after being added.\r\n   * If true, the listener would be automatically removed when invoked.\r\n   */\r\n  once?: boolean\r\n\r\n  /**\r\n   * A Boolean indicating that it should wait for listener processing.\r\n   * If true, the next listener will not be executed until the listener processing is completed.\r\n   */\r\n  wait?: boolean\r\n\r\n  /**\r\n   * An object to be passed as an argument of the listener.\r\n   */\r\n  data?: T\r\n}\r\n\r\n/** Argument object that the listener receives. */\r\nexport type EventHandlerListenerEvent<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> = {\r\n  /** This represents the name of the event. */\r\n  type: U\r\n\r\n  /** This represents the class that received the event. */\r\n  target: V\r\n\r\n  /**\r\n   * This is the initial value for options passed to the event.\r\n   * When passed, it may be overwritten.\r\n   */\r\n  data: T\r\n}\r\n\r\n/** This represents a listener. */\r\nexport type EventHandlerListener<T extends { [key: string]: any } = {}, U extends string = string, V extends EventHandler = EventHandler> =\r\n  (ev: EventHandlerListenerEvent<T, U, V>) => void | Promise<void>\r\n\r\n/** This represents the data map when it was dispatched. */\r\nexport type EventHandlerDataMap = {\r\n  [key: string]: { [key: string]: any }\r\n}\r\n\r\nclass EventHandler<M extends EventHandlerDataMap = EventHandlerDataMap> {\r\n  private readonly _map: Map<string, { listener: EventHandlerListener<any, any, any>, options: EventHandlerOptions }[]> = new Map()\r\n\r\n  /**\r\n   * Add a new listener.\r\n   * @param type This represents the name of the event.\r\n   * @param listener This represents the listener to add.\r\n   * @param options Specifies characteristics about the event listener.\r\n   */\r\n  addEventListener<T extends Extract<keyof M, string>, U extends Partial<M[T]> = M[T], V extends this = this> (\r\n    type: T,\r\n    listener: EventHandlerListener<M[T] & U, T, V>,\r\n    options: EventHandlerOptions<U> = {}\r\n  ) {\r\n    let onMaps = this._map.get(type)\r\n    if (!onMaps) {\r\n      onMaps = []\r\n      this._map.set(type, onMaps)\r\n    }\r\n\r\n    let isAdd = true\r\n\r\n    for (const onMap of onMaps) {\r\n      if (onMap.listener === listener) {\r\n        onMap.options = options\r\n        isAdd = false\r\n        break\r\n      }\r\n    }\r\n\r\n    if (isAdd) { onMaps.push({ listener, options }) }\r\n\r\n    return isAdd\r\n  }\r\n\r\n  /**\r\n   * Remove the listener.\r\n   * @param type This represents the name of the event.\r\n   * @param listener This represents the listener to remove.\r\n   */\r\n  removeEventListener (type: Extract<keyof M, string>, listener: EventHandlerListener) {\r\n    const onMaps = this._map.get(type)\r\n    if (onMaps) {\r\n      let index = 0\r\n      for (const onMap of onMaps) {\r\n        if (onMap.listener === listener) {\r\n          onMaps.splice(index, 1)\r\n          return true\r\n        }\r\n\r\n        index++\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Execute the registered event.\r\n   * @param type This represents the name of the event.\r\n   * @param data An object to be passed as an argument of the listener.\r\n   */\r\n  async dispatchEvent<T extends Extract<keyof M, string>> (type: T, data: M[T] = {} as M[T]) {\r\n    const promises: (Promise<void> | void)[] = []\r\n\r\n    const onMaps = this._map.get(type)\r\n    if (onMaps) {\r\n      for (const { listener, options } of [...onMaps]) {\r\n        const event = {\r\n          type,\r\n          target: this,\r\n          data: { ...(options.data || {}), ...data }\r\n        }\r\n\r\n        const promise = listener(event)\r\n        promises.push(promise)\r\n\r\n        if (options.once) { this.removeEventListener(type, listener) }\r\n        if (options.wait) { await promise }\r\n      }\r\n    }\r\n\r\n    await Promise.all(promises)\r\n  }\r\n}\r\n\r\nexport default EventHandler\r\n"],"names":[],"mappings":";;AA4CA,MAAM,YAAY;IAAlB;QACmB,SAAI,GAAmG,IAAI,GAAG,EAAE,CAAA;KAmFlI;;;;;;;IA3EC,gBAAgB,CACd,IAAO,EACP,QAA8C,EAC9C,UAAkC,EAAE;QAEpC,IAAI,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAChC,IAAI,CAAC,MAAM,EAAE;YACX,MAAM,GAAG,EAAE,CAAA;YACX,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,MAAM,CAAC,CAAA;SAC5B;QAED,IAAI,KAAK,GAAG,IAAI,CAAA;QAEhB,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;YAC1B,IAAI,KAAK,CAAC,QAAQ,KAAK,QAAQ,EAAE;gBAC/B,KAAK,CAAC,OAAO,GAAG,OAAO,CAAA;gBACvB,KAAK,GAAG,KAAK,CAAA;gBACb,MAAK;aACN;SACF;QAED,IAAI,KAAK,EAAE;YAAE,MAAM,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,CAAA;SAAE;QAEjD,OAAO,KAAK,CAAA;KACb;;;;;;IAOD,mBAAmB,CAAE,IAA8B,EAAE,QAA8B;QACjF,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAClC,IAAI,MAAM,EAAE;YACV,IAAI,KAAK,GAAG,CAAC,CAAA;YACb,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;gBAC1B,IAAI,KAAK,CAAC,QAAQ,KAAK,QAAQ,EAAE;oBAC/B,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAA;oBACvB,OAAO,IAAI,CAAA;iBACZ;gBAED,KAAK,EAAE,CAAA;aACR;SACF;QAED,OAAO,KAAK,CAAA;KACb;;;;;;IAOD,MAAM,aAAa,CAAsC,IAAO,EAAE,OAAa,EAAU;QACvF,MAAM,QAAQ,GAA6B,EAAE,CAAA;QAE7C,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,CAAA;QAClC,IAAI,MAAM,EAAE;YACV,KAAK,MAAM,EAAE,QAAQ,EAAE,OAAO,EAAE,IAAI,CAAC,GAAG,MAAM,CAAC,EAAE;gBAC/C,MAAM,KAAK,GAAG;oBACZ,IAAI;oBACJ,MAAM,EAAE,IAAI;oBACZ,IAAI,EAAE,EAAE,IAAI,OAAO,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,GAAG,IAAI,EAAE;iBAC3C,CAAA;gBAED,MAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAA;gBAC/B,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAA;gBAEtB,IAAI,OAAO,CAAC,IAAI,EAAE;oBAAE,IAAI,CAAC,mBAAmB,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;iBAAE;gBAC9D,IAAI,OAAO,CAAC,IAAI,EAAE;oBAAE,MAAM,OAAO,CAAA;iBAAE;aACpC;SACF;QAED,MAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAA;KAC5B;;;;;"}